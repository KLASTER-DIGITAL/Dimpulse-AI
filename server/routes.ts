import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { randomUUID } from "crypto";
import { insertChatSchema, insertMessageSchema } from "@shared/schema";
import fetch from "node-fetch";

export async function registerRoutes(app: Express): Promise<Server> {
  // Get all chats (for the sidebar)
  app.get("/api/chats", async (req, res) => {
    try {
      const chats = await storage.getChatsByUserId(null);
      res.json(chats);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch chats" });
    }
  });

  // Create a new chat
  app.post("/api/chats", async (req, res) => {
    try {
      const chatId = randomUUID();
      const chatData = insertChatSchema.parse({
        id: chatId,
        title: "New Chat",
        userId: null,
      });

      const chat = await storage.createChat(chatData);
      
      // –ë–æ–ª—å—à–µ –Ω–µ —Å–æ–∑–¥–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
      // –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ, –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –±—É–¥–µ—Ç –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å—Å—è –Ω–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–µ
      
      res.status(201).json(chat);
    } catch (error) {
      res.status(400).json({ message: "Failed to create chat" });
    }
  });

  // Get a specific chat with its messages
  app.get("/api/chats/:chatId", async (req, res) => {
    try {
      const chatId = req.params.chatId;
      const chat = await storage.getChatById(chatId);
      
      if (!chat) {
        return res.status(404).json({ message: "Chat not found" });
      }
      
      const messages = await storage.getMessagesByChatId(chatId);
      res.json({ chat, messages });
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch chat" });
    }
  });



  // Send a message and get a response from the AI
  app.post("/api/chats/:chatId/messages", async (req, res) => {
    try {
      const chatId = req.params.chatId;
      const { content, audioData } = req.body;
      
      if (!content || typeof content !== 'string') {
        return res.status(400).json({ message: "Message content is required" });
      }
      
      // Create user message
      const userMessageData = insertMessageSchema.parse({
        chatId,
        role: "user",
        content,
      });
      
      await storage.createMessage(userMessageData);
      
      // –≠—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –æ—à–∏–±–∫–∞ 404 —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º –æ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–º webhook
      // –í –¥—Ä—É–≥–∏—Ö —Å–ª—É—á–∞—è—Ö –±—É–¥–µ–º –∂–¥–∞—Ç—å –æ—Ç–≤–µ—Ç–∞ –æ—Ç webhook
      let aiResponse = "";
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ webhook
      const webhookUrl = 'https://n8n.klaster.digital/webhook-test/4a1fed67-dcfb-4eb8-a71b-d47b1d651509';
      
      // –ù–µ –≤—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—É—é –∞–∫—Ç–∏–≤–∞—Ü–∏—é webhook, —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ä—É—á–Ω–∞—è –∞–∫—Ç–∏–≤–∞—Ü–∏—è
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–∞ webhook
      const requestTime = new Date().toISOString();
      const requestBody: any = { 
        message: content,
        // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ç–µ–∫—Å—Ç–æ–º –∏ –≥–æ–ª–æ—Å–æ–º
        message_data: {
          text: content,
          // voice –±—É–¥–µ—Ç null –µ—Å–ª–∏ –Ω–µ—Ç –∞—É–¥–∏–æ–¥–∞–Ω–Ω—ã—Ö
          voice: audioData || null
        },
        // –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º—è –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
        timestamp: requestTime,
        request_time: requestTime
      };
      
      // –ï—Å–ª–∏ –µ—Å—Ç—å –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ, –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö —Ç–∞–∫–∂–µ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
      // –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      if (audioData) {
        requestBody.audio = audioData;
        console.log("Including audio data in webhook request (audio data length: " + (audioData?.length || 0) + " characters)");
      }
      
      console.log("Sending webhook request:", {
        url: webhookUrl,
        body: { 
          message: content, 
          hasAudio: !!audioData,
          hasVoice: !!audioData,
          messageData: requestBody.message_data
        }
      });
      console.log("Request payload size:", JSON.stringify(requestBody).length, "bytes");
      
      try {
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody),
        });
        
        console.log("Webhook response status:", response.status);
        
        // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ JSON
        try {
          const data = await response.json();
          console.log("Webhook response data:", JSON.stringify(data, null, 2));
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ª—É—á–∏–ª–∏ –ª–∏ –º—ã –æ—Ç–≤–µ—Ç –æ –Ω–µ–∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–º webhook
          if (response.status === 404 && data && data.message && 
              data.message.includes("webhook") && 
              data.message.includes("not registered")) {
            aiResponse = "üîÑ –î–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ:\n\n1. –û—Ç–∫—Ä—ã—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å n8n –ø–æ –∞–¥—Ä–µ—Å—É:\n   https://n8n.klaster.digital\n\n2. –ù–∞–π—Ç–∏ –ø–æ—Ç–æ–∫ —Å webhook ID:\n   4a1fed67-dcfb-4eb8-a71b-d47b1d651509\n\n3. –ù–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É 'Test workflow'\n\n4. –í–µ—Ä–Ω—É—Ç—å—Å—è —Å—é–¥–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ";
            console.log("Using detailed Russian error message for webhook not registered");
          }
          // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ –æ—Ç–≤–µ—Ç–∞ –æ—Ç webhook
          else if (data) {
            // –í–∞—Ä–∏–∞–Ω—Ç 1: –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            if (Array.isArray(data)) {
              const item = data[0];
              if (item) {
                if (typeof item === 'string') {
                  aiResponse = item;
                } else if (item.message && item.message.content) {
                  aiResponse = item.message.content;
                } else if (item.output) {
                  aiResponse = item.output;
                } else if (item.choices && item.choices[0] && item.choices[0].message && item.choices[0].message.content) {
                  aiResponse = item.choices[0].message.content;
                } else if (item.text) {
                  aiResponse = item.text;
                } else if (item.result) {
                  aiResponse = item.result;
                }
              }
            } 
            // –í–∞—Ä–∏–∞–Ω—Ç 2: –û–±—ä–µ–∫—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ OpenAI API
            else if (data.choices && data.choices[0]) {
              if (data.choices[0].message && data.choices[0].message.content) {
                aiResponse = data.choices[0].message.content;
              } else if (data.choices[0].text) {
                aiResponse = data.choices[0].text;
              }
            }
            // –í–∞—Ä–∏–∞–Ω—Ç 3: –ü—Ä–æ—Å—Ç–æ–π –æ–±—ä–µ–∫—Ç —Å –æ—Ç–≤–µ—Ç–æ–º
            else if (data.response) {
              aiResponse = data.response;
            }
            // –í–∞—Ä–∏–∞–Ω—Ç 4: –û–±—ä–µ–∫—Ç —Å –ø–æ–ª–µ–º text –∏–ª–∏ content
            else if (data.text) {
              aiResponse = data.text;
            } else if (data.content) {
              aiResponse = data.content;
            }
            // –í–∞—Ä–∏–∞–Ω—Ç 5: –û–±—ä–µ–∫—Ç —Å –ø–æ–ª–µ–º message (–µ—Å–ª–∏ —ç—Ç–æ –Ω–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ webhook)
            else if (data.message && !data.message.includes("webhook") && !data.message.includes("not registered")) {
              aiResponse = data.message;
            }
            // –í–∞—Ä–∏–∞–Ω—Ç 6: –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç JSON
            else if (typeof data === 'string') {
              aiResponse = data;
            }
            
            // –ï—Å–ª–∏ –æ—Ç–≤–µ—Ç –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –Ω–∏ –æ–¥–Ω–∏–º –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, –Ω–æ –µ—Å—Ç—å –æ–±—ä–µ–∫—Ç JSON
            if (aiResponse === "" && data) {
              // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤–µ—Å—å –æ–±—ä–µ–∫—Ç –≤ —Å—Ç—Ä–æ–∫—É –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
              aiResponse = JSON.stringify(data);
            }
          }
        } catch (jsonError) {
          console.log("Error parsing JSON from webhook:", jsonError);
          // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ JSON
          try {
            const textResponse = await response.text();
            console.log("Webhook text response:", textResponse);
            if (textResponse && textResponse.length > 0) {
              aiResponse = textResponse;
            } else if (response.status === 200) {
              // –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å 200, –Ω–æ –æ—Ç–≤–µ—Ç –ø—É—Å—Ç–æ–π, –ø—Ä–æ—Å—Ç–æ –∂–¥–µ–º –æ—Ç–≤–µ—Ç–∞ –æ—Ç webhook
              aiResponse = "typing";
              // –ù–µ —Å–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞, –µ—Å–ª–∏ –Ω–µ—Ç –æ—Ç–≤–µ—Ç–∞ - –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
              return res.status(201).json({
                id: -1,
                chatId,
                role: "assistant",
                content: aiResponse,
                createdAt: new Date().toISOString(),
                typing: true
              });
            }
          } catch (textError) {
            console.log("Error getting text from webhook:", textError);
            // –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç, –∂–¥–µ–º –æ—Ç–≤–µ—Ç–∞ –æ—Ç webhook
            if (response.status === 200) {
              aiResponse = "typing";
              // –ù–µ —Å–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞, –µ—Å–ª–∏ –Ω–µ—Ç –æ—Ç–≤–µ—Ç–∞
              return res.status(201).json({
                id: -1,
                chatId,
                role: "assistant",
                content: aiResponse,
                createdAt: new Date().toISOString(),
                typing: true
              });
            }
          }
        }
      } catch (error) {
        console.log("Error contacting webhook:", error);
        // –û—Å—Ç–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
      }
      
      // Create AI message
      const aiMessageData = insertMessageSchema.parse({
        chatId,
        role: "assistant",
        content: aiResponse,
      });
      
      const aiMessage = await storage.createMessage(aiMessageData);
      
      res.status(201).json(aiMessage);
    } catch (error) {
      console.error("Message error:", error);
      res.status(500).json({ message: "Failed to process message" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
